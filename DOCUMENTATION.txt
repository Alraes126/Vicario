# Documentación del Proyecto: Casino Vicario

Este documento explica la estructura y el funcionamiento del proyecto "Casino Vicario", una aplicación de escritorio desarrollada con Python y Tkinter. El objetivo es proporcionar una guía clara y accesible para entender cómo está construida la aplicación, sus principios de diseño y cómo interactúan sus diferentes componentes.

---

## 1. Visión General del Proyecto

"Casino Vicario" es una aplicación de casino simple que permite a los usuarios registrarse, iniciar sesión, jugar a una máquina tragamonedas, ver su historial de apuestas y transacciones, y gestionar su saldo. La aplicación está diseñada para ser modular y fácil de entender, siguiendo patrones de diseño comunes en el desarrollo de software.

---

## 2. Arquitectura del Proyecto: Modelo-Vista-Controlador (MVC)

El proyecto sigue el patrón de diseño **Modelo-Vista-Controlador (MVC)**. Este patrón ayuda a separar las responsabilidades de la aplicación en tres componentes principales, lo que mejora la organización, la mantenibilidad y la escalabilidad del código.

*   **Modelo (Model)**:
    *   **¿Qué es?** Es la parte de la aplicación que gestiona los datos y la lógica de negocio. Se encarga de interactuar con la base de datos, realizar validaciones de datos y ejecutar operaciones relacionadas con la información.
    *   **En este proyecto:** Los archivos en el directohaz un pushrio `models/` (ej. `user_model.py`, `bet_model.py`, `transaction_model.py`) son los Modelos. Ellos saben cómo guardar y recuperar información de la base de datos (a través de `DatabaseConnector`). No tienen conocimiento de la interfaz de usuario.
    *   **Ejemplo:** En `models/user_model.py`, la clase `UserModel` contiene métodos como `create_user`, `get_user_by_email_and_password` y `update_user_balance`. Estos métodos interactúan directamente con la base de datos para gestionar los datos de los usuarios.

*   **Vista (View)**:
    *   **¿Qué es?** Es la parte de la aplicación que el usuario ve y con la que interactúa. Se encarga de la presentación de los datos y de capturar las acciones del usuario (clics, entradas de texto).
    *   **En este proyecto:** Los archivos en el directorio `views/` (ej. `login_window.py`, `user_dashboard.py`, `slot_machine.py`) son las Vistas. Están construidas con `tkinter` y `ttk` y muestran la información al usuario, pero no contienen lógica de negocio ni interactúan directamente con la base de datos.
    *   **Ejemplo:** En `views/login_window.py`, la clase `LoginWindow` define la interfaz gráfica para el inicio de sesión, incluyendo campos de texto para email y contraseña, y botones. Su método `create_widgets` es el encargado de construir esta interfaz.

*   **Controlador (Controller)**:
    *   **¿Qué es?** Actúa como un intermediario entre el Modelo y la Vista. Recibe las acciones del usuario desde la Vista, las procesa (a menudo interactuando con el Modelo para obtener o actualizar datos), y luego actualiza la Vista con los nuevos resultados.
    *   **En este proyecto:** Los archivos en el directorio `controllers/` (ej. `login_controller.py`, `dashboard_controller.py`, `slot_machine_controller.py`) son los Controladores. Contienen la lógica para manejar eventos de la GUI, validar entradas y coordinar las operaciones entre Vistas y Modelos.
    *   **Ejemplo:** En `controllers/login_controller.py`, la clase `LoginController` tiene el método `login_user`. Este método recibe el email y la contraseña de la `LoginWindow` (Vista), valida estos datos, los envía a `UserModel` (Modelo) para verificar, y luego le indica a la `LoginWindow` que muestre un mensaje de éxito o error.

**Interacción MVC (Ejemplo: Inicio de Sesión):**
1.  El usuario ingresa sus credenciales en la **Vista** (`LoginWindow`) y hace clic en el botón "Ingresar".
2.  La **Vista** (`LoginWindow`) llama a su **Controlador** (`LoginController`) a través del método `self.controller.login_user(email, password)`.
3.  El **Controlador** (`LoginController`) procesa la acción:
    *   Valida el formato del email y que los campos no estén vacíos.
    *   Solicita al **Modelo** (`UserModel`) que verifique las credenciales llamando a `self.user_model.get_user_by_email_and_password(email, password)`.
4.  El **Modelo** (`UserModel`) realiza la consulta a la base de datos y devuelve el resultado (el objeto usuario o `None`) al **Controlador**.
5.  El **Controlador** recibe el resultado del **Modelo** y decide cómo actualizar la **Vista**.
6.  Si el login es exitoso, el **Controlador** llama a `self.view.on_login_success(user)` para que la **Vista** (`LoginWindow`) limpie los campos y cambie a la pestaña del Dashboard. También propaga los datos del usuario a otros controladores (ej. `dashboard_controller.set_current_user(user)`).

---

## 3. Principios de Programación Orientada a Objetos (POO)

El proyecto está construido utilizando **Programación Orientada a Objetos (POO)**, lo que significa que el código se organiza en torno a "objetos" que combinan datos y funciones que operan sobre esos datos.

*   **Clases y Objetos**:
    *   **Clase**: Es un plano o plantilla para crear objetos. Define las propiedades (atributos) y los comportamientos (métodos) que tendrán los objetos de ese tipo.
    *   **Objeto**: Es una instancia de una clase.
    *   **En el proyecto:**
        *   **Clase:** `UserModel` (definida en `models/user_model.py`).
        *   **Objeto:** En `Main.py`, la línea `user_model = UserModel(db_connector)` crea un objeto (una instancia) de la clase `UserModel`. Este objeto `user_model` puede entonces usar los métodos definidos en la clase `UserModel` (ej. `user_model.create_user(...)`).

*   **Encapsulamiento**:
    *   **¿Qué es?** Es el principio de agrupar los datos (atributos) y los métodos que operan sobre esos datos dentro de una única unidad (la clase), y de ocultar los detalles internos de implementación.
    *   **En el proyecto:** La clase `UserModel` (en `models/user_model.py`) encapsula toda la lógica de cómo se guardan y recuperan los usuarios de la base de datos. Otras partes de la aplicación (como los controladores) solo necesitan llamar a métodos públicos como `user_model.create_user()` sin preocuparse por las consultas SQL internas o la gestión de la conexión a la base de datos.

*   **Inyección de Dependencias**:
    *   **¿Qué es?** Es un patrón de diseño donde un objeto recibe otros objetos de los que depende (sus "dependencias") en lugar de crearlos él mismo. Esto hace que el código sea más flexible y fácil de probar.
    *   **En el proyecto:** Puedes ver esto claramente en los constructores (`__init__`) de muchas clases.
        *   **Ejemplo:** En `controllers/bet_controller.py`, el constructor es `def __init__(self, view, bet_model, user_model, game_model):`. Aquí, `BetController` no crea `view`, `bet_model`, `user_model` o `game_model`, sino que los recibe como argumentos. Esto permite que `Main.py` (o cualquier otra parte que cree el `BetController`) decida qué implementaciones específicas de la vista o los modelos pasarle.

*   **Responsabilidad Única (SRP - Single Responsibility Principle)**:
    *   **¿Qué es?** Cada clase debe tener una única razón para cambiar, es decir, debe tener una única responsabilidad bien definida.
    *   **En el proyecto:**
        *   `UserModel` (Modelo) solo se encarga de la gestión de datos de usuarios en la base de datos.
        *   `LoginWindow` (Vista) solo se encarga de la presentación visual del formulario de login.
        *   `LoginController` (Controlador) solo se encarga de la lógica de interacción del login.
    *   Esto evita que una clase se vuelva demasiado grande o compleja, facilitando su mantenimiento y comprensión.

---

## 4. Librerías Clave Utilizadas

El proyecto utiliza varias librerías de Python para diferentes funcionalidades:

*   **`tkinter` y `tkinter.ttk`**:
    *   **Propósito:** Son las bibliotecas estándar de Python para crear interfaces gráficas de usuario (GUI). `ttk` proporciona widgets con un aspecto más moderno y personalizable.
    *   **Uso:** Se utilizan en todas las clases `View` para construir la interfaz de usuario (ventanas, botones, campos de texto, tablas, etc.).
    *   **Ejemplo:** En `views/login_window.py`, `tk.Tk()` crea la ventana principal y `ttk.Entry` crea los campos de entrada.

*   **`mysql.connector`**:
    *   **Propósito:** Es el conector oficial de MySQL para Python, permitiendo que la aplicación se comunique con una base de datos MySQL.
    *   **Uso:** Se utiliza en `models/Database/database_manager.py` para establecer y gestionar la conexión a la base de datos y ejecutar consultas SQL.
    *   **Ejemplo:** En `models/Database/database_manager.py`, `mysql.connector.connect(**db_config)` establece la conexión a la base de datos.

*   **`PIL` (Pillow)**:
    *   **Propósito:** Es una biblioteca de procesamiento de imágenes que añade capacidades de manipulación de imágenes a Python.
    *   **Uso:** Se utiliza en `models/user_model.py` para redimensionar y convertir imágenes de perfil antes de guardarlas en la base de datos, y en `views/user_dashboard.py` para cargar y mostrar esas imágenes.
    *   **Ejemplo:** En `models/user_model.py`, `Image.open(io.BytesIO(image_data))` abre una imagen desde datos binarios.

*   **`tkcalendar`**:
    *   **Propósito:** Es un widget de calendario para Tkinter, que facilita la selección de fechas a través de un calendario interactivo.
    *   **Uso:** Se utiliza en `views/register_window.py` para la selección de la fecha de nacimiento y en `views/bets_window.py` y `views/transaction_window.py` para filtrar por rango de fechas.
    *   **Ejemplo:** En `views/register_window.py`, `DateEntry(frame, ...)` crea un widget de entrada de fecha con un calendario.

*   **`openpyxl`**:
    *   **Propósito:** Una biblioteca para leer y escribir archivos Excel 2010 (.xlsx).
    *   **Uso:** Se utiliza en `controllers/bet_controller.py` y `controllers/transaction_controller.py` para exportar datos de apuestas y transacciones a archivos Excel.
    *   **Ejemplo:** En `controllers/bet_controller.py`, `openpyxl.Workbook()` crea un nuevo archivo Excel.

*   **`Fpdf`**:
    *   **Propósito:** Una biblioteca para generar archivos PDF de forma sencilla.
    *   **Uso:** Se utiliza en `controllers/bet_controller.py` y `controllers/transaction_controller.py` para exportar datos de apuestas y transacciones a archivos PDF.
    *   **Ejemplo:** En `controllers/bet_controller.py`, `pdf = FPDF()` crea un nuevo documento PDF.

*   **`python-dotenv` (`dotenv`)**:
    *   **Propósito:** Permite cargar variables de entorno desde un archivo `.env` en el proyecto, lo que es útil para gestionar configuraciones sensibles (como credenciales de base de datos) sin exponerlas en el código fuente.
    *   **Uso:** Se utiliza en `models/config/settings.py` para cargar la configuración de la base de datos.
    *   **Ejemplo:** En `models/config/settings.py`, `load_dotenv()` carga las variables de entorno.

*   **`re` (Expresiones Regulares)**:
    *   **Propósito:** Módulo estándar de Python para trabajar con expresiones regulares, que son patrones de búsqueda de texto.
    *   **Uso:** Se utiliza en `controllers/login_controller.py` y `controllers/register_controller.py` para validar el formato de las direcciones de correo electrónico y otros campos de texto.
    *   **Ejemplo:** En `controllers/login_controller.py`, `re.match(email_regex, email)` valida el formato de un email.

---

## 5. Estructura del Proyecto

El proyecto está organizado en los siguientes directorios principales:

*   **`Main.py`**: El punto de entrada principal de la aplicación. Aquí se inicializa la ventana principal, el sistema de pestañas y se conectan todos los Modelos, Vistas y Controladores.
*   **`assets/`**: Directorio para almacenar recursos estáticos como imágenes (ej. iconos, imágenes de placeholder).
*   **`controllers/`**: Contiene la lógica de los Controladores. Cada archivo `*_controller.py` maneja la lógica de interacción para una parte específica de la aplicación.
*   **`models/`**: Contiene la lógica de los Modelos. Cada archivo `*_model.py` gestiona los datos y la interacción con la base de datos para una entidad específica.
    *   **`models/Database/`**: Contiene `database_manager.py`, que es la clase encargada de la conexión y ejecución de consultas a la base de datos.
    *   **`models/config/`**: Contiene `settings.py`, donde se carga la configuración de la base de datos desde el archivo `.env`.
*   **`views/`**: Contiene la lógica de las Vistas. Cada archivo `*_window.py` define la interfaz gráfica de usuario para una ventana o sección de la aplicación.

---

## 6. Cómo Ejecutar el Proyecto

Para ejecutar el proyecto, sigue estos pasos:

1.  **Clonar el Repositorio** (si aplica).
2.  **Configurar el Entorno Virtual** (recomendado):
    ```bash
    python -m venv .venv
    .venv\Scripts\activate   # En Windows
    source .venv/bin/activate # En macOS/Linux
    ```
3.  **Instalar Dependencias**:
    ```bash
    pip install -r requirements.txt
    ```
4.  **Crear Archivo `.env`**:
    Crea un archivo llamado `.env` en la raíz del proyecto con la configuración de tu base de datos MySQL. Ejemplo:
    ```
    DB_HOST=localhost
    DB_NAME=casino_db
    DB_USER=root
    DB_PASSWORD=your_password
    DB_PORT=3306
    ```
    Asegúrate de reemplazar `casino_db` y `your_password` con los valores correctos de tu configuración de MySQL.
5.  **Ejecutar la Aplicación**:
    ```bash
    python Main.py
    ```

---

## 7. Estilo de Código y Comentarios

El código fuente incluye comentarios detallados diseñados para ser educativos y fáciles de entender. Se explican las importaciones de librerías, los principios de POO (como MVC, encapsulamiento, inyección de dependencias, SRP) y la lógica de negocio. Esto facilita el aprendizaje y la comprensión del funcionamiento interno de la aplicación.

---